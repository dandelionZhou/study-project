### 为什么要用到缓存？
##### 高性能
##### 高并发
### 用缓存后带来的问题？
##### 缓存与数据库双写不一致
##### 缓存雪崩
##### 缓存穿透
##### 缓存击穿
### Redis的线程模型
##### 文件事件处理器
+ 多个socket
+ IO多路复用机制
+ 文件事件分派器
+ 事件处理器
##### 为什么Redis单线程却能支持高并发？
+ 纯内存操作
+ 核心时基于非阻塞的IO多路复用机制
+ C语言实现
+ 单线程避免了多线程的频繁上下文切换问题，竞争问题
##### 什么是非阻塞的IO多路复用机制？
##### Redis的一次通信过程
1. 客户端socekt01向Redis进程的server socket发送连接请求；
2. Redis的server sokcet收到请求后产生AE_READABLE事件
3. IO多路复用程序监听到server socket产生的事件后，将该socket01压入队列；
4. 文件事件分派器从队列中获取socket，交给连接应答处理器；
5. 连接应答处理器会创建一个与客户端socket01通信的socket，并将其与命令请求处理器关联；
6. 客户端socket01发送一个命令请求到Redis进程；
7. Redis中与之通信的socekt01会产生AE_READABLE事件；
8. IO多路复用程序监听到事件产生后，将其压入队列；
9. 文件事件分派器从队列中获取该事件时，发现该事件已与命令请求处理器关联，则将事件交给命令请求处理器处理；
10. 命令处理器读取socket01中的命令并执行，操作完成后，将socket01与命令回复处理器关联；
11. 如果客户端准备好接收结果，socket01产生AE_WRITEABLE事件并压入队列；
12. 文件事件分派器发现socket01与命令回复处理器关联则将socekt01交给关联的命令回复处理器；
13. 返回结果后，解除socket01的事件关联。 

### Redis的数据类型
+ String 字符串
+ Hashes 哈希
存储基本的对象信息，如用户登录信息等
+ Lists 有序列表
粉丝列表，文章评论，营销系统的跟进指令
+ Sets 去重集合
+ Sorted Sets 有序去重集合

### Redis写的数据一定会存在？
##### Redis的过期策略
定期删除+惰性删除
+ 定期删除：每隔一段时间随机抽取一些设置了过期时间的key，检测是否过期，如果过期就删除
+ 惰性删除：在获取key时会检查key是否过期，如果过期就删除，不返回任何东西
##### Redis的内存淘汰机制
Redis的过期策略仍然解决不了大量过期key堆积在内存中，导致Redis内存耗尽，因此有了Redis的内存淘汰机制，主要包括以下几个：
+ noeviction: 当内存不足时，新写入会报错。。。太不友好了，基本没啥用
+ `allkeys-lru`: 当内存不足时，在键空间，移除最近最少使用的key ->这个最长用，LRU算法移除最近最少用的key
+ allkeys-random：当内存不足时，随机移除某个key。。。基本没人用把，这万一把热点key移除了就完蛋了
+ volatile-lru：当内存不足时，在设置了过期时间的键空间，移除最近最少使用的key
+ volatile-random：当内存不足时，在设置了过期时间的键空间，随机移除某个key
+ volatile-ttl：当内存不足时，在设置过期时间的键空间，移除更早过期时间的key
##### RLU算法
找出最近最少使用的数据，实现思路如下：
###### 数组
每次都要循环数组，时间复杂度O(logn)
1. 定义一个定长的数组，每个数组维护一个对象(key键值，count初始值0)
2. 每次放入一个对象就循环数组对所有对象的count+1
3. 每次使用一个对象就将该对象的count置为0
4. 找出最近最少使用的数据，就是循环遍历数组，找到count最大那个
###### 链表
###### 哈希表+链表
###### LinkedHashMap
### Redis 主从架构
一主多从，主负责写，从负责读
##### 主从复制的核心机制
+ Redis采用异步方式复制数据到slave节点
+ 一个master node可以配置多个slave node
+ slave node可以连接其他slave node
+ slave node复制时不会阻塞master node


+ slave node做复制时，也不会阻塞自己，会返回旧的数据集；但是复制完成后，删除旧数据，加载新数据集时会暂停对外服务
+ slave node主要用来进行横向扩容，做读写分离，提高读的吞吐量
##### 主从复制的核心原理
1. 启动一个slave node，会发送`PSYNC`命令给master node
2. 如果是slave node初次连接，那么会触发一次全量复制
3. master node会启动一个后台线程，生成一份`RDB`快照文件，同时还会将从客户端新收到的所有命令缓存在内存
4. master会将生成的`RDB`文件发送给slave
5. slave会先写入本地磁盘，然后再从本地磁盘加载到内存
6. slave将快照文件加载到内存后，master会将内存中缓存的命令发送到slave
7. slave会执行这些命令来同步数据
##### 主从复制的断点续传
如果主从复制过程中，网络连接故障，那么恢复后可以接着上次复制的地方继续复制
##### 无磁盘化复制
    repl-diskless-sync yes
如果配置文件中开启了以上参数，则master直接在内存创建`RDB`文件发送给slave，不会在本次磁盘创建
##### 过期key处理
slave不会过期key,只会等master过期key，如果master过期key或淘汰key，那么会模拟一条del命令发送给slave
### Redis高可用
##### Redis持久化方式
###### RDB
RDB持久化机制，是对Redis中数据执行周期性的持久化
###### AOF
AOF机制对每条写入命令作为日志，以`append-only`的模式写入一个日志文件中